/* automatically generated by rust-bindgen 0.59.1 */

pub const LZ4_VERSION_MAJOR: u32 = 1;
pub const LZ4_VERSION_MINOR: u32 = 9;
pub const LZ4_VERSION_RELEASE: u32 = 3;
pub const LZ4_VERSION_NUMBER: u32 = 10903;
pub const LZ4_MEMORY_USAGE: u32 = 14;
pub const LZ4_MAX_INPUT_SIZE: u32 = 2113929216;
pub const LZ4_HASHLOG: u32 = 12;
pub const LZ4_HASHTABLESIZE: u32 = 16384;
pub const LZ4_HASH_SIZE_U32: u32 = 4096;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const LZ4_STREAMSIZE: u32 = 16416;
pub const LZ4HC_CLEVEL_MIN: u32 = 3;
pub const LZ4HC_CLEVEL_DEFAULT: u32 = 9;
pub const LZ4HC_CLEVEL_OPT_MIN: u32 = 10;
pub const LZ4HC_CLEVEL_MAX: u32 = 12;
pub const LZ4HC_DICTIONARY_LOGSIZE: u32 = 16;
pub const LZ4HC_MAXD: u32 = 65536;
pub const LZ4HC_MAXD_MASK: u32 = 65535;
pub const LZ4HC_HASH_LOG: u32 = 15;
pub const LZ4HC_HASHTABLESIZE: u32 = 32768;
pub const LZ4HC_HASH_MASK: u32 = 32767;
pub const LZ4_STREAMHCSIZE: u32 = 262200;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
extern "C" {
    pub fn LZ4_versionNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_versionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " LZ4_compress_default() :"]
    #[doc = "  Compresses 'srcSize' bytes from buffer 'src'"]
    #[doc = "  into already allocated 'dst' buffer of size 'dstCapacity'."]
    #[doc = "  Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize)."]
    #[doc = "  It also runs faster, so it's a recommended setting."]
    #[doc = "  If the function cannot compress 'src' into a more limited 'dst' budget,"]
    #[doc = "  compression stops *immediately*, and the function result is zero."]
    #[doc = "  In which case, 'dst' content is undefined (invalid)."]
    #[doc = "      srcSize : max supported value is LZ4_MAX_INPUT_SIZE."]
    #[doc = "      dstCapacity : size of buffer 'dst' (which must be already allocated)"]
    #[doc = "     @return  : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity)"]
    #[doc = "                or 0 if compression fails"]
    #[doc = " Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer)."]
    pub fn LZ4_compress_default(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe() :"]
    #[doc = "  compressedSize : is the exact complete size of the compressed block."]
    #[doc = "  dstCapacity : is the size of destination buffer (which must be already allocated), presumed an upper bound of decompressed size."]
    #[doc = " @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity)"]
    #[doc = "           If destination buffer is not large enough, decoding will stop and output an error code (negative value)."]
    #[doc = "           If the source stream is detected malformed, the function will stop decoding and return a negative result."]
    #[doc = " Note 1 : This function is protected against malicious data packets :"]
    #[doc = "          it will never writes outside 'dst' buffer, nor read outside 'source' buffer,"]
    #[doc = "          even if the compressed block is maliciously modified to order the decoder to do these actions."]
    #[doc = "          In such case, the decoder stops immediately, and considers the compressed block malformed."]
    #[doc = " Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them."]
    #[doc = "          The implementation is free to send / store / derive this information in whichever way is most beneficial."]
    #[doc = "          If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead."]
    pub fn LZ4_decompress_safe(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compressBound() :"]
    #[doc = "Provides the maximum size that LZ4 compression may output in a \"worst case\" scenario (input data not compressible)"]
    #[doc = "This function is primarily useful for memory allocation purposes (destination buffer size)."]
    #[doc = "Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example)."]
    #[doc = "Note that LZ4_compress_default() compresses faster when dstCapacity is >= LZ4_compressBound(srcSize)"]
    #[doc = "inputSize  : max supported value is LZ4_MAX_INPUT_SIZE"]
    #[doc = "return : maximum output size in a \"worst case\" scenario"]
    #[doc = "or 0, if input size is incorrect (too large or negative)"]
    pub fn LZ4_compressBound(inputSize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast() :"]
    #[doc = "Same as LZ4_compress_default(), but allows selection of \"acceleration\" factor."]
    #[doc = "The larger the acceleration value, the faster the algorithm, but also the lesser the compression."]
    #[doc = "It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed."]
    #[doc = "An acceleration value of \"1\" is the same as regular LZ4_compress_default()"]
    #[doc = "Values <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT (currently == 1, see lz4.c)."]
    #[doc = "Values > LZ4_ACCELERATION_MAX will be replaced by LZ4_ACCELERATION_MAX (currently == 65537, see lz4.c)."]
    pub fn LZ4_compress_fast(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_extState() :"]
    #[doc = "  Same as LZ4_compress_fast(), using an externally allocated memory space for its state."]
    #[doc = "  Use LZ4_sizeofState() to know how much memory must be allocated,"]
    #[doc = "  and allocate it on 8-bytes boundaries (using `malloc()` typically)."]
    #[doc = "  Then, provide this buffer as `void* state` to compression function."]
    pub fn LZ4_sizeofState() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_fast_extState(
        state: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_destSize() :"]
    #[doc = "  Reverse the logic : compresses as much data as possible from 'src' buffer"]
    #[doc = "  into already allocated buffer 'dst', of size >= 'targetDestSize'."]
    #[doc = "  This function either compresses the entire 'src' content into 'dst' if it's large enough,"]
    #[doc = "  or fill 'dst' buffer completely with as much data as possible from 'src'."]
    #[doc = "  note: acceleration parameter is fixed to \"default\"."]
    #[doc = ""]
    #[doc = " *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'."]
    #[doc = "               New value is necessarily <= input value."]
    #[doc = " @return : Nb bytes written into 'dst' (necessarily <= targetDestSize)"]
    #[doc = "           or 0 if compression fails."]
    #[doc = ""]
    #[doc = " Note : from v1.8.2 to v1.9.1, this function had a bug (fixed un v1.9.2+):"]
    #[doc = "        the produced compressed content could, in specific circumstances,"]
    #[doc = "        require to be decompressed into a destination buffer larger"]
    #[doc = "        by at least 1 byte than the content to decompress."]
    #[doc = "        If an application uses `LZ4_compress_destSize()`,"]
    #[doc = "        it's highly recommended to update liblz4 to v1.9.2 or better."]
    #[doc = "        If this can't be done or ensured,"]
    #[doc = "        the receiving decompression function should provide"]
    #[doc = "        a dstCapacity which is > decompressedSize, by at least 1 byte."]
    #[doc = "        See https://github.com/lz4/lz4/issues/859 for details"]
    pub fn LZ4_compress_destSize(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_partial() :"]
    #[doc = "  Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',"]
    #[doc = "  into destination buffer 'dst' of size 'dstCapacity'."]
    #[doc = "  Up to 'targetOutputSize' bytes will be decoded."]
    #[doc = "  The function stops decoding on reaching this objective."]
    #[doc = "  This can be useful to boost performance"]
    #[doc = "  whenever only the beginning of a block is required."]
    #[doc = ""]
    #[doc = " @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize)"]
    #[doc = "           If source stream is detected malformed, function returns a negative result."]
    #[doc = ""]
    #[doc = "  Note 1 : @return can be < targetOutputSize, if compressed block contains less data."]
    #[doc = ""]
    #[doc = "  Note 2 : targetOutputSize must be <= dstCapacity"]
    #[doc = ""]
    #[doc = "  Note 3 : this function effectively stops decoding on reaching targetOutputSize,"]
    #[doc = "           so dstCapacity is kind of redundant."]
    #[doc = "           This is because in older versions of this function,"]
    #[doc = "           decoding operation would still write complete sequences."]
    #[doc = "           Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,"]
    #[doc = "           it could write more bytes, though only up to dstCapacity."]
    #[doc = "           Some \"margin\" used to be required for this operation to work properly."]
    #[doc = "           Thankfully, this is no longer necessary."]
    #[doc = "           The function nonetheless keeps the same signature, in an effort to preserve API compatibility."]
    #[doc = ""]
    #[doc = "  Note 4 : If srcSize is the exact size of the block,"]
    #[doc = "           then targetOutputSize can be any value,"]
    #[doc = "           including larger than the block's decompressed size."]
    #[doc = "           The function will, at most, generate block's decompressed size."]
    #[doc = ""]
    #[doc = "  Note 5 : If srcSize is _larger_ than block's compressed size,"]
    #[doc = "           then targetOutputSize **MUST** be <= block's decompressed size."]
    #[doc = "           Otherwise, *silent corruption will occur*."]
    pub fn LZ4_decompress_safe_partial(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        targetOutputSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_stream_t = LZ4_stream_u;
extern "C" {
    pub fn LZ4_createStream() -> *mut LZ4_stream_t;
}
extern "C" {
    pub fn LZ4_freeStream(streamPtr: *mut LZ4_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream_fast() : v1.9.0+"]
    #[doc = "  Use this to prepare an LZ4_stream_t for a new chain of dependent blocks"]
    #[doc = "  (e.g., LZ4_compress_fast_continue())."]
    #[doc = ""]
    #[doc = "  An LZ4_stream_t must be initialized once before usage."]
    #[doc = "  This is automatically done when created by LZ4_createStream()."]
    #[doc = "  However, should the LZ4_stream_t be simply declared on stack (for example),"]
    #[doc = "  it's necessary to initialize it first, using LZ4_initStream()."]
    #[doc = ""]
    #[doc = "  After init, start any new stream with LZ4_resetStream_fast()."]
    #[doc = "  A same LZ4_stream_t can be re-used multiple times consecutively"]
    #[doc = "  and compress multiple streams,"]
    #[doc = "  provided that it starts each new stream with LZ4_resetStream_fast()."]
    #[doc = ""]
    #[doc = "  LZ4_resetStream_fast() is much faster than LZ4_initStream(),"]
    #[doc = "  but is not compatible with memory regions containing garbage data."]
    #[doc = ""]
    #[doc = "  Note: it's only useful to call LZ4_resetStream_fast()"]
    #[doc = "        in the context of streaming compression."]
    #[doc = "        The *extState* functions perform their own resets."]
    #[doc = "        Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive."]
    pub fn LZ4_resetStream_fast(streamPtr: *mut LZ4_stream_t);
}
extern "C" {
    #[doc = " LZ4_loadDict() :"]
    #[doc = "  Use this function to reference a static dictionary into LZ4_stream_t."]
    #[doc = "  The dictionary must remain available during compression."]
    #[doc = "  LZ4_loadDict() triggers a reset, so any previous data will be forgotten."]
    #[doc = "  The same dictionary will have to be loaded on decompression side for successful decoding."]
    #[doc = "  Dictionary are useful for better compression of small data (KB range)."]
    #[doc = "  While LZ4 accept any input as dictionary,"]
    #[doc = "  results are generally better when using Zstandard's Dictionary Builder."]
    #[doc = "  Loading a size of 0 is allowed, and is the same as reset."]
    #[doc = " @return : loaded dictionary size, in bytes (necessarily <= 64 KB)"]
    pub fn LZ4_loadDict(
        streamPtr: *mut LZ4_stream_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_continue() :"]
    #[doc = "  Compress 'src' content using data from previously compressed blocks, for better compression ratio."]
    #[doc = " 'dst' buffer must be already allocated."]
    #[doc = "  If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster."]
    #[doc = ""]
    #[doc = " @return : size of compressed block"]
    #[doc = "           or 0 if there is an error (typically, cannot fit into 'dst')."]
    #[doc = ""]
    #[doc = "  Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block."]
    #[doc = "           Each block has precise boundaries."]
    #[doc = "           Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata."]
    #[doc = "           It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together."]
    #[doc = ""]
    #[doc = "  Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !"]
    #[doc = ""]
    #[doc = "  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB."]
    #[doc = "           Make sure that buffers are separated, by at least one byte."]
    #[doc = "           This construction ensures that each block only depends on previous block."]
    #[doc = ""]
    #[doc = "  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB."]
    #[doc = ""]
    #[doc = "  Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed."]
    pub fn LZ4_compress_fast_continue(
        streamPtr: *mut LZ4_stream_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_saveDict() :"]
    #[doc = "  If last 64KB data cannot be guaranteed to remain available at its current memory location,"]
    #[doc = "  save it into a safer place (char* safeBuffer)."]
    #[doc = "  This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),"]
    #[doc = "  but is much faster, because LZ4_saveDict() doesn't need to rebuild tables."]
    #[doc = " @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error."]
    pub fn LZ4_saveDict(
        streamPtr: *mut LZ4_stream_t,
        safeBuffer: *mut ::std::os::raw::c_char,
        maxDictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_streamDecode_t = LZ4_streamDecode_u;
extern "C" {
    #[doc = " LZ4_createStreamDecode() and LZ4_freeStreamDecode() :"]
    #[doc = "  creation / destruction of streaming decompression tracking context."]
    #[doc = "  A tracking context can be re-used multiple times."]
    pub fn LZ4_createStreamDecode() -> *mut LZ4_streamDecode_t;
}
extern "C" {
    pub fn LZ4_freeStreamDecode(LZ4_stream: *mut LZ4_streamDecode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_setStreamDecode() :"]
    #[doc = "  An LZ4_streamDecode_t context can be allocated once and re-used multiple times."]
    #[doc = "  Use this function to start decompression of a new stream of blocks."]
    #[doc = "  A dictionary can optionally be set. Use NULL or size 0 for a reset order."]
    #[doc = "  Dictionary is presumed stable : it must remain accessible and unmodified during next decompression."]
    #[doc = " @return : 1 if OK, 0 if error"]
    pub fn LZ4_setStreamDecode(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decoderRingBufferSize() : v1.8.2+"]
    #[doc = "  Note : in a ring buffer scenario (optional),"]
    #[doc = "  blocks are presumed decompressed next to each other"]
    #[doc = "  up to the moment there is not enough remaining space for next block (remainingSize < maxBlockSize),"]
    #[doc = "  at which stage it resumes from beginning of ring buffer."]
    #[doc = "  When setting such a ring buffer for streaming decompression,"]
    #[doc = "  provides the minimum size of this ring buffer"]
    #[doc = "  to be compatible with any source respecting maxBlockSize condition."]
    #[doc = " @return : minimum ring buffer size,"]
    #[doc = "           or 0 if there is an error (invalid maxBlockSize)."]
    pub fn LZ4_decoderRingBufferSize(maxBlockSize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_*_continue() :"]
    #[doc = "  These decoding functions allow decompression of consecutive blocks in \"streaming\" mode."]
    #[doc = "  A block is an unsplittable entity, it must be presented entirely to a decompression function."]
    #[doc = "  Decompression functions only accepts one block at a time."]
    #[doc = "  The last 64KB of previously decoded data *must* remain available and unmodified at the memory position where they were decoded."]
    #[doc = "  If less than 64KB of data has been decoded, all the data must be present."]
    #[doc = ""]
    #[doc = "  Special : if decompression side sets a ring buffer, it must respect one of the following conditions :"]
    #[doc = "  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize)."]
    #[doc = "    maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes."]
    #[doc = "    In which case, encoding and decoding buffers do not need to be synchronized."]
    #[doc = "    Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize."]
    #[doc = "  - Synchronized mode :"]
    #[doc = "    Decompression buffer size is _exactly_ the same as compression buffer size,"]
    #[doc = "    and follows exactly same update rule (block boundaries at same positions),"]
    #[doc = "    and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),"]
    #[doc = "    _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB)."]
    #[doc = "  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes."]
    #[doc = "    In which case, encoding and decoding buffers do not need to be synchronized,"]
    #[doc = "    and encoding ring buffer can have any size, including small ones ( < 64 KB)."]
    #[doc = ""]
    #[doc = "  Whenever these conditions are not possible,"]
    #[doc = "  save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,"]
    #[doc = "  then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block."]
    pub fn LZ4_decompress_safe_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_*_usingDict() :"]
    #[doc = "  These decoding functions work the same as"]
    #[doc = "  a combination of LZ4_setStreamDecode() followed by LZ4_decompress_*_continue()"]
    #[doc = "  They are stand-alone, and don't need an LZ4_streamDecode_t structure."]
    #[doc = "  Dictionary is presumed stable : it must remain accessible and unmodified during decompression."]
    #[doc = "  Performance tip : Decompression speed can be substantially increased"]
    #[doc = "                    when dst == dictStart + dictSize."]
    pub fn LZ4_decompress_safe_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapcity: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type LZ4_i8 = i8;
pub type LZ4_byte = u8;
pub type LZ4_u16 = u16;
pub type LZ4_u32 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_stream_t_internal {
    pub hashTable: [LZ4_u32; 4096usize],
    pub currentOffset: LZ4_u32,
    pub tableType: LZ4_u32,
    pub dictionary: *const LZ4_byte,
    pub dictCtx: *const LZ4_stream_t_internal,
    pub dictSize: LZ4_u32,
}
#[test]
fn bindgen_test_layout_LZ4_stream_t_internal() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_t_internal>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).hashTable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_stream_t_internal>())).currentOffset as *const _ as usize
        },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(currentOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).tableType as *const _ as usize },
        16388usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(tableType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_stream_t_internal>())).dictionary as *const _ as usize
        },
        16392usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).dictCtx as *const _ as usize },
        16400usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictCtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).dictSize as *const _ as usize },
        16408usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_streamDecode_t_internal {
    pub externalDict: *const LZ4_byte,
    pub extDictSize: size_t,
    pub prefixEnd: *const LZ4_byte,
    pub prefixSize: size_t,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_t_internal() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_t_internal>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).externalDict as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(externalDict)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).extDictSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(extDictSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).prefixEnd as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixEnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).prefixSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_stream_u {
    pub table: [*mut ::std::os::raw::c_void; 2052usize],
    pub internal_donotuse: LZ4_stream_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_stream_u() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_u>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_u>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_u>())).internal_donotuse as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " LZ4_initStream() : v1.9.0+"]
    #[doc = "  An LZ4_stream_t structure must be initialized at least once."]
    #[doc = "  This is automatically done when invoking LZ4_createStream(),"]
    #[doc = "  but it's not when the structure is simply declared on stack (for example)."]
    #[doc = ""]
    #[doc = "  Use LZ4_initStream() to properly initialize a newly declared LZ4_stream_t."]
    #[doc = "  It can also initialize any arbitrary buffer of sufficient size,"]
    #[doc = "  and will @return a pointer of proper type upon initialization."]
    #[doc = ""]
    #[doc = "  Note : initialization fails if size and alignment conditions are not respected."]
    #[doc = "         In which case, the function will @return NULL."]
    #[doc = "  Note2: An LZ4_stream_t structure guarantees correct alignment and size."]
    #[doc = "  Note3: Before v1.9.0, use LZ4_resetStream() instead"]
    pub fn LZ4_initStream(buffer: *mut ::std::os::raw::c_void, size: size_t) -> *mut LZ4_stream_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamDecode_u {
    pub table: [::std::os::raw::c_ulonglong; 4usize],
    pub internal_donotuse: LZ4_streamDecode_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_u() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_u>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_streamDecode_u>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_u>())).internal_donotuse as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " Obsolete compression functions (since v1.7.3)"]
    pub fn LZ4_compress(
        src: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput(
        src: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_withState(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_withState(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obsolete decompression functions (since v1.8.0)"]
    pub fn LZ4_uncompress(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        outputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_uncompress_unknownOutputSize(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        isize_: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_create(inputBuffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LZ4_sizeofStreamState() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamState(
        state: *mut ::std::os::raw::c_void,
        inputBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_slideInputBuffer(state: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Obsolete streaming decoding functions (since v1.7.0)"]
    pub fn LZ4_decompress_safe_withPrefix64k(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_withPrefix64k(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obsolete LZ4_decompress_fast variants (since v1.9.0) :"]
    #[doc = "  These functions used to be faster than LZ4_decompress_safe(),"]
    #[doc = "  but this is no longer the case. They are now slower."]
    #[doc = "  This is because LZ4_decompress_fast() doesn't know the input size,"]
    #[doc = "  and therefore must progress more cautiously into the input buffer to not read beyond the end of block."]
    #[doc = "  On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability."]
    #[doc = "  As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated."]
    #[doc = ""]
    #[doc = "  The last remaining LZ4_decompress_fast() specificity is that"]
    #[doc = "  it can decompress a block without knowing its compressed size."]
    #[doc = "  Such functionality can be achieved in a more secure manner"]
    #[doc = "  by employing LZ4_decompress_safe_partial()."]
    #[doc = ""]
    #[doc = "  Parameters:"]
    #[doc = "  originalSize : is the uncompressed size to regenerate."]
    #[doc = "                 `dst` must be already allocated, its size must be >= 'originalSize' bytes."]
    #[doc = " @return : number of bytes read from source buffer (== compressed size)."]
    #[doc = "           The function expects to finish at block's end exactly."]
    #[doc = "           If the source stream is detected malformed, the function stops decoding and returns a negative result."]
    #[doc = "  note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer."]
    #[doc = "         However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds."]
    #[doc = "         Also, since match offsets are not validated, match reads from 'src' may underflow too."]
    #[doc = "         These issues never happen if input (compressed) data is correct."]
    #[doc = "         But they may happen if input data is invalid (error or intentional tampering)."]
    #[doc = "         As a consequence, use these functions in trusted environments with trusted data **only**."]
    pub fn LZ4_decompress_fast(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream() :"]
    #[doc = "  An LZ4_stream_t structure must be initialized at least once."]
    #[doc = "  This is done with LZ4_initStream(), or LZ4_resetStream()."]
    #[doc = "  Consider switching to LZ4_initStream(),"]
    #[doc = "  invoking LZ4_resetStream() will trigger deprecation warnings in the future."]
    pub fn LZ4_resetStream(streamPtr: *mut LZ4_stream_t);
}
extern "C" {
    #[doc = " LZ4_compress_HC() :"]
    #[doc = "  Compress data from `src` into `dst`, using the powerful but slower \"HC\" algorithm."]
    #[doc = " `dst` must be already allocated."]
    #[doc = "  Compression is guaranteed to succeed if `dstCapacity >= LZ4_compressBound(srcSize)` (see \"lz4.h\")"]
    #[doc = "  Max supported `srcSize` value is LZ4_MAX_INPUT_SIZE (see \"lz4.h\")"]
    #[doc = " `compressionLevel` : any value between 1 and LZ4HC_CLEVEL_MAX will work."]
    #[doc = "                      Values > LZ4HC_CLEVEL_MAX behave the same as LZ4HC_CLEVEL_MAX."]
    #[doc = " @return : the number of bytes written into 'dst'"]
    #[doc = "           or 0 if compression fails."]
    pub fn LZ4_compress_HC(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_extStateHC() :"]
    #[doc = "  Same as LZ4_compress_HC(), but using an externally allocated memory segment for `state`."]
    #[doc = " `state` size is provided by LZ4_sizeofStateHC()."]
    #[doc = "  Memory segment must be aligned on 8-bytes boundaries (which a normal malloc() should do properly)."]
    pub fn LZ4_sizeofStateHC() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_HC_extStateHC(
        stateHC: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_destSize() : v1.9.0+"]
    #[doc = "  Will compress as much data as possible from `src`"]
    #[doc = "  to fit into `targetDstSize` budget."]
    #[doc = "  Result is provided in 2 parts :"]
    #[doc = " @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)"]
    #[doc = "           or 0 if compression fails."]
    #[doc = " `srcSizePtr` : on success, *srcSizePtr is updated to indicate how much bytes were read from `src`"]
    pub fn LZ4_compress_HC_destSize(
        stateHC: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_streamHC_t = LZ4_streamHC_u;
extern "C" {
    #[doc = " LZ4_createStreamHC() and LZ4_freeStreamHC() :"]
    #[doc = "  These functions create and release memory for LZ4 HC streaming state."]
    #[doc = "  Newly created states are automatically initialized."]
    #[doc = "  A same state can be used multiple times consecutively,"]
    #[doc = "  starting with LZ4_resetStreamHC_fast() to start a new stream of blocks."]
    pub fn LZ4_createStreamHC() -> *mut LZ4_streamHC_t;
}
extern "C" {
    pub fn LZ4_freeStreamHC(streamHCPtr: *mut LZ4_streamHC_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamHC_fast(
        streamHCPtr: *mut LZ4_streamHC_t,
        compressionLevel: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn LZ4_loadDictHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_HC_continue(
        streamHCPtr: *mut LZ4_streamHC_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_continue_destSize() : v1.9.0+"]
    #[doc = "  Similar to LZ4_compress_HC_continue(),"]
    #[doc = "  but will read as much data as possible from `src`"]
    #[doc = "  to fit into `targetDstSize` budget."]
    #[doc = "  Result is provided into 2 parts :"]
    #[doc = " @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)"]
    #[doc = "           or 0 if compression fails."]
    #[doc = " `srcSizePtr` : on success, *srcSizePtr will be updated to indicate how much bytes were read from `src`."]
    #[doc = "           Note that this function may not consume the entire input."]
    pub fn LZ4_compress_HC_continue_destSize(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_saveDictHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        safeBuffer: *mut ::std::os::raw::c_char,
        maxDictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4HC_CCtx_internal {
    pub hashTable: [LZ4_u32; 32768usize],
    pub chainTable: [LZ4_u16; 65536usize],
    pub end: *const LZ4_byte,
    pub base: *const LZ4_byte,
    pub dictBase: *const LZ4_byte,
    pub dictLimit: LZ4_u32,
    pub lowLimit: LZ4_u32,
    pub nextToUpdate: LZ4_u32,
    pub compressionLevel: ::std::os::raw::c_short,
    pub favorDecSpeed: LZ4_i8,
    pub dirty: LZ4_i8,
    pub dictCtx: *const LZ4HC_CCtx_internal,
}
#[test]
fn bindgen_test_layout_LZ4HC_CCtx_internal() {
    assert_eq!(
        ::std::mem::size_of::<LZ4HC_CCtx_internal>(),
        262192usize,
        concat!("Size of: ", stringify!(LZ4HC_CCtx_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4HC_CCtx_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4HC_CCtx_internal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).hashTable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).chainTable as *const _ as usize },
        131072usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(chainTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).end as *const _ as usize },
        262144usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).base as *const _ as usize },
        262152usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).dictBase as *const _ as usize },
        262160usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).dictLimit as *const _ as usize },
        262168usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).lowLimit as *const _ as usize },
        262172usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(lowLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).nextToUpdate as *const _ as usize
        },
        262176usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(nextToUpdate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).compressionLevel as *const _ as usize
        },
        262180usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(compressionLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).favorDecSpeed as *const _ as usize
        },
        262182usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(favorDecSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).dirty as *const _ as usize },
        262183usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).dictCtx as *const _ as usize },
        262184usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictCtx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamHC_u {
    pub table: [*mut ::std::os::raw::c_void; 32775usize],
    pub internal_donotuse: LZ4HC_CCtx_internal,
}
#[test]
fn bindgen_test_layout_LZ4_streamHC_u() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamHC_u>(),
        262200usize,
        concat!("Size of: ", stringify!(LZ4_streamHC_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamHC_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamHC_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_streamHC_u>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamHC_u),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamHC_u>())).internal_donotuse as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamHC_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    pub fn LZ4_initStreamHC(
        buffer: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut LZ4_streamHC_t;
}
extern "C" {
    pub fn LZ4_compressHC(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_limitedOutput(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_limitedOutput(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_limitedOutput_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_limitedOutput_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_continue(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_limitedOutput_continue(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_createHC(inputBuffer: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LZ4_slideInputBufferHC(
        LZ4HC_Data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LZ4_freeHC(LZ4HC_Data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_continue(
        LZ4HC_Data: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_limitedOutput_continue(
        LZ4HC_Data: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_sizeofStreamStateHC() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamStateHC(
        state: *mut ::std::os::raw::c_void,
        inputBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        compressionLevel: ::std::os::raw::c_int,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
